Function New-OPDscMetaClassModule {
    <#
            .SYNOPSIS
            Function to generate a module containing functions from DSC Meta class definitions.

            .DESCRIPTION
            Use this function to generate functions from DSC Partial class definitions. For each partial that allows metadata a separate .classes.ps1 file is created which enables us to validate the input.
            The functions generated by this function get the information from those classes and creates new functions, one for each class. The parameters are taken from the class and also validation attributes
            are copied from the class to the parameters. The result of the functions generated by this function can be used as a section which can be passed to Update-OPDscLcmConfigurationFile.

            The output of this command is a module, called DscMetaClassModule by default, which can be loaded and contains the functions generated from the classes.ps1 files.

            .EXAMPLE
            New-OPDscMetaClassModule -Path d:\repositories\dsc\Partial\IIS* -OutputPath 'd:\temp' 
       
            This example generates functions for all IIS*.classes.ps1 files found in d:\repositories\dsc\Partial. The generated functions are written to d:\temp\DscMetaClassModule

            .EXAMPLE
            New-OPDscMetaClassModule -Path d:\repositories\dsc\Partial\FileServer.classes.ps1 -OutputPath 'd:\temp' 
       
            This example generates functions for FileServer.classes.ps1. The generated functions (there can still be multiple if nested classes are found) are written to d:\temp\DscMetaClassModule
       
            .NOTES
            Author: Daniël Both
    #>

    [CmdletBinding(SupportsShouldProcess, ConfirmImpact='Low')]
    Param (
        # The path to the folder containing the classes.ps1 files, or target an individual classes.ps1 file.
        [Parameter(Mandatory)]
        [SupportsWildCards()]
        [string]$Path,

        # The directory to output the generated function, for example d:\repositories\modules
        [Parameter(Mandatory)]
        [ValidateScript({ Test-Path $_ -PathType Container })]
        [string]$OutputDirectory,
        
        # The name of the module to generate, defaults to DscMetaClassModule
        [Parameter()]
        [string]$ModuleName = 'DscMetaClassModule'
    )

    Function New-FunctionFromClass {
        [CmdletBinding()]
        Param (
            [type]$Class,
            [switch]$NestedType
        )
        
        $attributeTemplate = @"
`t`t[Parameter(Mandatory)]
{0}
"@ 

        $paramTemplate = @"
`t`t# The {2} for partial meta class {3}
{0}
`t`t[{1}]`${2},

"@ 

        $codeTemplate = @'
        [hashtable]@{{
            {0} = @(
                [hashtable]$PSBoundParameters
            )
        }}
'@

        $nestedCodeTemplate = @'
        [hashtable]$PSBoundParameters
'@

        $functionTemplateCode = @'
Function New-OPDscMeta{0}Object {{{{
    <#
        .SYNOPSIS
        Create a new {0} object for use in DSC metadata

        .DESCRIPTION
        This function generates a new object of type {0}. The result of this function is a new object 
        which can be passed to Update-OPDscLcmConfigurationFile to add the role {0} to the server.

        .EXAMPLE
    #>

    [CmdletBinding(SupportsShouldProcess,ConfirmImpact='Low')]
    [OutputType([System.Collections.Hashtable])]
    Param (
{1}
    )

    If($PSCmdlet.ShouldProcess('','Create new DSC Meta object of type {0}')){{{{
{2}
    }}}}
}}}}
'@

        $nestedClasses = @()
        $parameters = Foreach($parameter in $Class.DeclaredProperties) {

            $customAttributes = foreach($customAttribute in $parameter.CustomAttributes) {
                $attributeValue = If($customAttribute.ConstructorArguments.Value.count -gt 1) {
                    switch -Wildcard ($customAttribute.ConstructorArguments[0].ArgumentType.Name) {
                        'String*' {"'$($customAttribute.ConstructorArguments.Value.Value -join "','")'"}
                        'Int32' {"$($customAttribute.ConstructorArguments.Value -join ",")"}
                        default {Write-Error "Unmanaged type $($customAttribute.ConstructorArguments[0].ArgumentType.Name)"}
                    }
                }
                else {
                    if($customAttribute.ConstructorArguments.Value) {
                        switch -Wildcard ($customAttribute.ConstructorArguments.ArgumentType.Name) {
                            'String*' {"'$($customAttribute.ConstructorArguments.Value)'"}
                            'Int32' {$customAttribute.ConstructorArguments.Value}
                            default {Write-Error "Unmanaged type $($customAttribute.ConstructorArguments.ArgumentType.Name)"}
                        }
                    }
                }

                "`t`t[{0}({1})]" -f $customAttribute.AttributeType.FullName, $attributeValue
            }

            $attributes = ($attributeTemplate -f ($customAttributes -join "`n")).TrimEnd("`r`n")
            $type = $parameter.PropertyType
            $typeName = $type.ToString()
            
            If($type.Module.ScopeName -like '*.classes.ps1') {
                $nestedClasses += $typeName -replace '\W'
                $typeName = 'object[]'
            }
            
            ($paramTemplate -f $attributes, $typeName, $parameter.Name, $($Class.ToString()))
        }
        
        foreach($nestedClass in $nestedClasses) {
            Write-Verbose "Generate new function for class $nestedClass"
            New-FunctionFromClass -Class $nestedClass -NestedType
        }

        $formattedParameters = ($parameters -join "`n").TrimEnd(",`r`n")
        if($nestedType) {
            $functionTemplate = $functionTemplateCode -f '{0}','{1}', $nestedCodeTemplate
        }
        else {
            $functionTemplate = $functionTemplateCode -f '{0}','{1}', $codeTemplate
        }
        
        [pscustomobject]@{
            FunctionName = "New-OPDscMeta{0}Object" -f $Class.ToString()
            Function = $functionTemplate -f $Class.ToString(), $formattedParameters
        }
    }

    $files = Get-ChildItem -Path $Path -Filter *.classes.ps1
    $functions = $files | ForEach-Object {

        # dot source the classes file to load the class
        . $_.Fullname

        $className = $_.Name.Split('.')[0]
        Write-Verbose "Generate new function for class $className" 
        New-FunctionFromClass -Class $className
    }
    
    if($functions) {    
        $moduleSplat = @{
            Path = $OutputDirectory
            Name = $ModuleName
            Function = $functions.FunctionName
            Version = [version]'1.0.0.1'
            Description = 'This module is auto generated by the New-OPDscMetaClassModule function. It contains functions to generate objects that contain metadata required for partials. These objects can be passed to New-OPDscLcmConfigurationFile sections parameter'
            Tag = 'Dsc'
            ErrorAction = 'Stop'
            WhatIf = [bool]$PSBoundParameters['WhatIf']
            WarningAction = 'SilentlyContinue'
        }
    
        try{
            New-OPModule @moduleSplat

            $functions | ForEach-Object {
                $scriptPath = "$OutputDirectory\$ModuleName\$($_.FunctionName).ps1"
                If($PSCmdlet.ShouldProcess($scriptPath, "Write function $($_.FunctionName)")) {
                    Set-Content -Path $scriptPath -Value $_.Function -Encoding UTF8 -Force -ErrorAction Stop
                }
            }
        }
        catch {
            Throw "Failed to generate module $ModuleName with functions $($functions.FunctionName). Error: $_"
        }
    }
}